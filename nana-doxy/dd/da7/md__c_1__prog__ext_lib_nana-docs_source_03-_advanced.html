<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Nana C++ Library. Reference for users.: Advanced topics</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nana C++ Library. Reference for users.
   </div>
   <div id="projectbrief">What we need to use nana</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dd/da7/md__c_1__prog__ext_lib_nana-docs_source_03-_advanced.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Advanced topics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#desing">Think about the Design</a></li>
<li class="level1"><a href="#impl_b">How to implement a button</a><ul><li class="level2"><a href="#intro">1 Introduction</a></li>
<li class="level2"><a href="#impl">2. Implementation</a><ul><li class="level3"><a href="#manip">2.1 Window Manipulator</a></li>
<li class="level3"><a href="#trig">2.2. Drawer Trigger</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#tab">The tabstop in Nana.GUI</a></li>
<li class="level1"><a href="#block">A Method to prevent UI from blocking while busy</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="desing"></a>
Think about the Design</h1>
<p>Assuming the design of a framework that generates some data and it requires a module for representing these data in GUI. In general, we just introduce an interface for outputting these data, for example: </p>
<pre class="fragment">    struct data { std::string url; }; 
    class uiface 
    { public: 
            virtual ~uiface() = 0; 
            virtual void create_ui_element(const data&amp;) = 0; 
    }; 
    uiface::~uiface(){} 
    class framework 
    { public: 
            framework(): uiface_(0) 
            { 
                    data dat; 
                    dat.url = "stdex.sf.net"; 
                    cont_.push_back(dat); 
                    dat.url = "nanaproject.wordpress.com"; 
                    cont_.push_back(dat); 
            } 
            void set(uiface * uif) { uiface_ = uif; } 
            void work() 
            { if(uiface_) 
              { for(std::vector&lt;data&gt;::const_iterator i = cont_.begin(); i != cont_.end();   ++i) 
                    { uiface_-&gt;create_ui_element(*i); 
                    } 
              } 
            } 
      private: 
            uiface * uiface_; 
            std::vector&lt;data&gt; cont_; 
    }; 
</pre><p>Now we need a GUI and it creates some buttons for representing the data, and when a buttons is clicked, it outputs the data that button represents. And then, let’s define a GUI for that requirement. </p>
<pre class="fragment">    namespace ui 
    { 
            using namespace nana::gui; 
            class bar : public form, public uiface 
            { public: 
                    bar() { gird_.bind(*this); } 
              private: 
                    typedef std::pair&lt;std::shared_ptr&lt;button&gt;, data&gt; btn_pair; 
                               //Now we implement the virtual function that declared by uiface 
                    virtual void create_ui_element(const data&amp; dat) 
                    { 
                            btn_pair p(std::shared_ptr&lt;button&gt;(new button(*this)), dat); 
                                                      //Make the click event 
                            p.first-&gt;make_event&lt;events::click&gt;(*this, &amp;bar::_m_click); 
                            p.first-&gt;caption(nana::stringset_cast(dat.url)); 
                            gird_.push(*(p.first), 0, 22); 
                            ui_el_.push_back(p); 
                    } 
                      private: 
                    void _m_click(const eventinfo&amp; ei) 
                    { 
                            //Check which button is clicked 
                            for(std::vector&lt;btn_pair&gt;::iterator i = ui_el_.begin(); i != ui_el_.end();++i) 
                            { if(i-&gt;first-&gt;handle() == ei.window) 
                              {     //Show data 
                                    i-&gt;second; 
                                    std::cout&lt;&lt;"open "&lt;&lt;i-&gt;second.url&lt;&lt;std::endl; 
                                    break; 
                              } 
                            } 
                    } 
                     private: 
                    gird gird_; 
                    std::vector&lt;btn_pair&gt; ui_el_; 
            }; 
    } 
</pre><p>It's done for implementing the GUI. Let's make the framework work. </p>
<pre class="fragment">    #include &lt;nana/gui/wvl.hpp&gt; 
    #include &lt;nana/gui/widgets/button.hpp&gt; 
    #include &lt;nana/gui/layout.hpp&gt; 
    #include &lt;iostream&gt; 
    include definition of framework... 
    int main() 
    { 
    ui::bar bar; 
    bar.show(); 
    framework fw; 
    fw.set(&amp;bar); 
    fw.work(); 
    nana::exec(); 
    } 
</pre><p>Run the program. Refer to figure 2.2, when we click a button, the program would output the data that is represented by button.</p>
<div class="image">
<img src="../../framework.jpg" alt="framework.jpg"/>
<div class="caption">
Figure 2.2 Design of a framework</div></div>
<p> Let's rethink the implementation of class bar. It is a bit complicated, because a check of which button is clicked is needed. In fact, we can reduce the complexity of previous design by employing function object. Think about the following implementation. </p>
<pre class="fragment">    class bar : public form, public uiface 
    {   struct command 
            {  data dat; 
               command(const data&amp; d): dat(d) {} 
                    void operator()() { std::cout&lt;&lt;"open "&lt;&lt;dat.url&lt;&lt;std::endl; } 
            }; 
      public: 
            bar() { gird_.bind(*this); } 
      private: 
                                                     //Now we implement the virtual function declared by uiface 
            virtual void create_ui_element(const data&amp; dat) 
            { 
              std::shared_ptr&lt;button&gt; p(new button(*this)); 
                                                                             //Make the click event 
              p-&gt;make_event&lt;events::click&gt;(command(dat)); 
              p-&gt;caption(nana::stringset_cast(dat.url)); 
              gird_.push(*p, 0, 22); 
              ui_el_.push_back(p); 
            } 
      private: 
            gird gird_; 
            std::vector&lt;std::shared_ptr&lt;button&gt; &gt; ui_el_; 
    }; 
</pre><p>As you see it, the new implementation is more convenient. The check of which button is clicked and the pair structure are removed. In C++11, the standard library provides a bind function. Generating a function object by using <a class="elRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/utility/functional/bind.html">std::bind()</a> instead of giving a explicit definition of a class that used for a function. Let's remove the definition of struct bar::command and reimplement the create_ui_element(). </p>
<pre class="fragment">    virtual void create_ui_element(const data&amp; dat) 
    { 
            std::shared_ptr&lt;button&gt; p(new button(*this)); 
             //Make the click event 
            typedef nana::functor&lt;void()&gt; fun; //or std::function&lt;void()&gt; 
            p-&gt;make_event&lt;events::click&gt; ( fun (std::bind( &amp;bar::_m_click, this, dat) )); 
            p-&gt;caption(nana::stringset_cast(dat.url)); 
            gird_.push(*p, 0, 22); 
            ui_el_.push_back(p); 
    } 
    void _m_click(const data&amp; dat) 
    { 
       std::cout&lt;&lt;"open "&lt;&lt;dat.url&lt;&lt;std::endl; 
    } 
</pre><p>The member function <code>_m_click()</code> is very tiny, we can remove it with lambda expression in C++11.</p>
<p>The main idea of this section is binding the execution context at some place in code and retaining the context for future use. As above code shown, we bind the data with a function object, and when the function object is called, we could easily refer to the data. By using the reasonable technical idioms, we can make the code more slighter, more expressive, the benefits are: flexible application, less comment and easy maintenance.</p>
<h1><a class="anchor" id="impl_b"></a>
How to implement a button</h1>
<h2><a class="anchor" id="intro"></a>
1 Introduction</h2>
<p>This article explain how to implement a button widget and some basic knowledge about <a class="el" href="../../d7/dc0/classnana_1_1button.html" title="Define a button widget and provides the interfaces to be operational. ">nana::button</a>. It is a simple widget and a good start point to learn the implementation of a widget. The implementation of <a class="el" href="../../d7/dc0/classnana_1_1button.html" title="Define a button widget and provides the interfaces to be operational. ">nana::button</a> is defined in *"include/nana/gui/widgets/button.hpp"* and *"source/gui/widgets/button.cpp".*</p>
<p>Nana.GUI provides the framework for implementing a widget. A GUI-widget is made of a window manipulator and a drawer trigger, so, to implement a widget we need to implement these two parts.</p>
<p><em>Window Manipulator</em></p>
<p>This class provides some operations that make the widget visible for a user. For example <a class="el" href="../../d7/dc0/classnana_1_1button.html" title="Define a button widget and provides the interfaces to be operational. ">nana::button</a> is a manipulator.</p>
<p><em>Drawer Trigger</em></p>
<p>A drawing operation is driven by the drawer trigger. It provied the internal of a widget, reacting to events and is invisible for an user. During the life time of a window manipulator and a drawer trigger, Nana.GUI does not involve creation and destruction of a drawer trigger.</p>
<h2><a class="anchor" id="impl"></a>
2. Implementation</h2>
<h3><a class="anchor" id="manip"></a>
2.1 Window Manipulator</h3>
<pre class="fragment">    template&lt;typename DrawerTrigger&gt;
    class basic_button: public widget_object&lt;category::widget_tag, DrawerTrigger&gt;
    {public:
    basic_button(){}
    basic_button(nana::widget&amp; widget, int x, int y, unsigned width,
                            unsigned height)
    { this-&gt;create(widget.handle(), x, y, width, height);
    }
    };
</pre><p>This code defines the window manipulator of the button. </p>
<pre class="fragment">    template&lt;typename DrawerTrigger&gt;
</pre><p>The template parameter DrawerTrigger is used to specify a drawer trigger.</p>
<p>basic_button inherit from widget_object&lt;category::widget_tag, DrawerTrigger&gt;. The widget_tag indicates the button is a Widget Window. Although all widgets are inherited from <a class="el" href="../../d9/dd8/classnana_1_1widget.html" title="Abstract class for defining the capacity interface. ">nana::widget</a>, the widgets just can be inherited from the template class widget_object&lt;&gt;.</p>
<p>The default constructor does not create the widget unless the create() method is called. The second constructor will create the widget by calling the create() method. Nana.GUI guarantees the safety if an operation on a widget before its creation.</p>
<h3><a class="anchor" id="trig"></a>
2.2. Drawer Trigger</h3>
<p>A drawer trigger is more complicate than a window manipulator; it reacts to mouse and keyboard events. In this implementation of the button, the code for drawing the button is written inside the drawer trigger directly. Now, let's dip into the definition of the drawer trigger.</p>
<p>A drawer trigger must be inherited from std::drawer_trigger. </p>
<pre class="fragment">    using namespace nana;
    class button_drawer: public nana::drawer_trigger&lt;cagetory::widget_tag&gt;
    {public:
            button_drawer ();
            void bind_window(nana::widget &amp; widget);
     private:
            void attached(nana::paint::graphics &amp;gra );
            void detached();
            void normal     (paint::graphics &amp;gra);
            void mouse_leave(paint::graphics &amp;gra, const eventinfo &amp;ei);
            void mouse_down (paint::graphics &amp;gra, const eventinfo &amp;ei);
            void mouse_up   (paint::graphics &amp;gra, const eventinfo &amp;ei);
            void focus              (paint::graphics &amp;gra, const eventinfo &amp;ei);
     private:
            void _m_draw_title(paint::graphics&amp;, bool is_mouse_down, bool is_focus);
            void _m_draw_background(paint::graphics&amp;, bool is_mouse_down);
            void _m_draw_border(paint::graphics&amp;, bool is_mouse_down);

            nana::widget* widget_ ;
            bool            is_ms_down_ ;
            bool            is_focus_ ;
    };
</pre><p>This button_drawer makes the constructor and a bind_window() member function public, and others private.</p>
<p>void bind_window(nana::widget&amp; widget){widget_ = }</p>
<p>Nana.GUI creates a widget and tells the drawer trigger the widget through bind_window().</p>
<p>The private member functions with don't start with <em>m</em> are virtual functions that are defined by <a class="el" href="../../d7/d16/classnana_1_1drawer__trigger.html">nana::drawer_trigger</a>. These virtual functions are invoked inside the Nana.GUI. The name of some of these virtual functions starts with mouse_ because they are used for answering to mouse operations. You need to override these functions if you want some special capacities.</p>
<p>The private member functions with start with <em>m</em> are defined by the button drawer trigger. They implements the drawing of the button. As will be readily seen, when a mouse event is raised, the drawer trigger calls these member functions for drawing the widget. </p>
<pre class="fragment">    nana::widget * widget_;
</pre><p>This data member refers to a window manipulator which is connecting with the drawer trigger. </p>
<pre class="fragment">    bool is_ms_down_;
</pre><p>This indicates the current status of the left mouse button (is pressed down?).</p>
<p>Now, let's return to the details of member functions with start with <em>m</em>. </p>
<pre class="fragment">    button_drawer::button_drawer()
    :widget_(0), is_ms_down_(false), is_focus_(false)
    {}
</pre><p>The default constructor initializes the data members. is_ms_down_ will be modified by mouse_down() and by mouse_up(). is_focus_ will be modified by focus(). </p>
<pre class="fragment">    void button_drawer::set(nana::widget&amp; widget)
    {  if(widget_ == 0) widget_ = &amp;widget;
    }
</pre><p>Sets widget_, this function is invoked by window manipulator's get_drawer_trigger(). The following member functions are the essential of the drawer trigger. </p>
<pre class="fragment">    void button_drawer::attached(nana::paint::graphics&amp;)
    {
            using namespace nana::API;
            is_ms_down_ = false;
            nana::window window = widget_-&gt;handle();
            make_drawer_event&lt;events::mouse_leave&gt;(window);
            make_drawer_event&lt;events::mouse_down&gt;(window);
            make_drawer_event&lt;events::mouse_up&gt;(window);
            make_drawer_event&lt;events::focus&gt;(window);
    }
</pre><p>When a widget is creating, Nana.GUI is responsible for attaching the drawer trigger which is returned by the window manipulator to the Window Manager of Nana.GUI, at the same time, Nana.GUI calls the <code>attach()</code> method provided by the drawer trigger, in other words, the <code>attach()</code> method is the first method of a drawer trigger that Nana.GUI calls. When the drawer trigger is attached to the Window Manager, the connection is created between the drawer trigger and window manipulator that the drawer trigger will receive the callback of an event from a widget. In this member function, button_drawer registers the events through the handle of window manipulator. The drawer trigger has a special function for registering an event(it is different with <code>nana::API::register_event</code> and <code>make_event()</code> of a window manipulator). Register an event, and Nana.GUI calls back the corresponding function for answering the event. In button_drawer's <code>attach()</code>, it registers mouse_leave, mouse_down and mouse_up, you can register more events if you want button more specially good effect. The attach() has a parameter, it refers to a <a class="el" href="../../d6/d47/classnana_1_1paint_1_1graphics.html" title="off-screen resource defined as ref-counting, can refer one resource ">nana::paint::graphics</a> object, this object is the off-screen buffer of the widget, any drawing operation on this object, it will be displayed on the monitor. This object is created and destroyed by Nana.GUI. There is not any operation on this object. </p>
<pre class="fragment">    void button_drawer::detached()
    { nana::API::unregister_drawer_event(widget_-&gt;handle()); }
</pre><p>When a drawer trigger is detached from the Window Manager, Nana.GUI will callback the detach() method. In the button_drawer implementation, we just unregister the events that we registered in attach(). nana::API::unregister_drawer_event is responsible for destroying the all registered events for the specified window. </p>
<pre class="fragment">    void button_drawer::normal(paint::graphics&amp; ghc)
    {
            _m_draw_background      (ghc, is_ms_down_);
            _m_draw_border          (ghc, is_ms_down_);
            _m_draw_title           (ghc, is_ms_down_, is_focus);
    }
</pre><p>The normal() method defined by a drawer trigger will be invoked after a widget is created completely, and <a class="el" href="../../d5/d1e/namespacenana_1_1_a_p_i.html#a339d6643ba8abd72b0c48839cda71046" title=": calls refresh() of a widget&#39;s drawer. if currently state is lazy_refresh, Nana.GUI may paste the dr...">nana::API::refresh_window()</a> will also invoke this normal() method. In this implementation, the normal() method calls the member functions start with <em>m</em> for operating the graphics object. </p>
<pre class="fragment">    void button_drawer::mouse_leave(paint::graphics&amp; ghc, const eventinfo&amp;)
    {
            _m_draw_background      (ghc, false);
            _m_draw_border          (ghc, false);
            _m_draw_title           (ghc, false, is_focus_);
            nana::API::lazy_refresh();
    }
</pre><p>When the mouse leaves the widget, Nana.GUI will call the mouse_leave, where the second parameter refers to an eventinfo object which provides some event information. In this implementation we don't take care about this parameter. It's worth noting that <a class="el" href="../../d5/d1e/namespacenana_1_1_a_p_i.html#a91a7f8cf23689ffa353728efbe7ba2bc" title="A widget drawer draws the widget surface in answering an event. ">nana::API::lazy_refresh()</a> is invoked last, it will let the graphics object display on monitor. lazy_refresh() only works in an event callback, hence we can't find it in normal() method. mouse_down(), mouse_up() and focus() are similar to mouse_leave(). Refer to "source/gui/widgets/button.cpp" for the details. Refer to Nana.Paint for the details of <a class="el" href="../../d6/d47/classnana_1_1paint_1_1graphics.html" title="off-screen resource defined as ref-counting, can refer one resource ">nana::paint::graphics</a>.</p>
<h1><a class="anchor" id="tab"></a>
The tabstop in Nana.GUI</h1>
<p>A tabstop is used for switching the keyboard focus between two widgets by pressing the Tab. Nana.GUI defines 3 states for tabstop.</p>
<p>Every Nana.GUI window defaultly does not take care about the tabstop, but when implement a widget, programmers must pay attention to the tabstop. If a widget owns the tabstop, the widget would catch the keyboard focus when the Tab key is pressed. If a widget is eating-tab, the widget can deal with the tab in the key_char event, and the focus could not change. A textbox is eating-tab. If a widget does not take care about the tabstop, it will ignore the message.</p>
<p>There are two functions about the tabstop defined in <a class="el" href="../../d5/d1e/namespacenana_1_1_a_p_i.html">nana::API</a>. tabstop is used for setting a widget owns a tabstop, eat_tabstop is used for setting a widget as eating tabstop. A widget can be set both tabstop and eat_tabstop . For example, for a textbox that has been set both tabstop and eat_tabstop, if the textbox is not focused, a user can press the Tab key to switch the focus on it, and when the user press a Tab key again, a Tab character is inputted into the textbox and the focus is not changed.</p>
<h1><a class="anchor" id="block"></a>
A Method to prevent UI from blocking while busy</h1>
<p>The GUI of Nana C++ Library (0.1.12 or later) is designed to save developers from the difficulties of threading, however, no UI framework will ever be able to provide a single-threaded solution for every sort of problem.</p>
<p>Most respondence to user interactions in events are finished immediately, and does not affect the responsiveness of the UI. The Nana C++ Library event model deals with events in sequence; this means the next event will be processed after current event is finished.</p>
<p>Consider the following example: </p>
<pre class="fragment">    #include &lt;nana/gui/wvl.hpp&gt;
    #include &lt;nana/gui/widgets/button.hpp&gt;
    #include &lt;nana/gui/widgets/progressbar.hpp&gt;
    class example : public nana::form
    {public:
            example()
            {
                    btn_start_.create(*this, 10, 10, 100, 20);
                    btn_start_.caption(STR("Start"));
                    btn_start_.events().click(*this, &amp;example::_m_start);
                    btn_cancel_.create(*this, 120, 10, 100, 20);
                    btn_cancel_.caption(STR("Cancel"));
                    btn_cancel_.events().click(*this, &amp;example::_m_cancel);
                    prog_.create(*this, 10, 40, 280, 20);
            }
     private:
            void _m_start()
            {
                    working_ = true;
                    btn_start_.enabled(false);
                    prog_.amount(100);
                    for(int i = 0; i &lt; 100 &amp;&amp; working_; ++i)
                    {
                            nana::system::sleep(1000); //a long-running simulation
                            prog_.value(i + 1);
                    }
                    btn_start_.enabled(true);
            }
            void _m_cancel(){working_ = false;}

            bool                            working_ ;
            nana::button    btn_start_ ;
            nana::button    btn_cancel_ ;
            nana::progressbar prog_ ;
    };

    int main()
    {
            example ex;
            ex.show();
            nana::exec();
            return 0;
    }
</pre><p>This simple application simulates a long-running operation, and designed a button for start and a button for cancel the work. However, it is not difficult to imagine, <code>_m_start()</code> spends a long time to run while click the "Start" button, it does affect the responsiveness of the UI. The "Cancel" button does not work until the work is finish, only thing you can do is just wait.</p>
<div class="image">
<img src="../../long-running.jpg" alt="long-running.jpg"/>
</div>
<p>Usually, the answer to handle the long-running operation in a separate thread, leaving the UI thread free to respond to user interface. When the long-running opertion is complete, it can report its result back to the UI thread for display.</p>
<p>Consider the following solution: </p>
<pre class="fragment">    #include &lt;nana/gui/wvl.hpp&gt;
    #include &lt;nana/gui/widgets/button.hpp&gt;
    #include &lt;nana/gui/widgets/progressbar.hpp&gt;
    #include &lt;nana/threads/pool.hpp&gt;
    class example : public nana::form
    {
     public:
            example()
            {
                    btn_start_.create(*this, 10, 10, 100, 20);
                    btn_start_.caption(STR("Start"));
                    btn_start_.events().click(nana::threads::pool_push(pool_, *this, &amp;example::_m_start));
                    btn_cancel_.create(*this, 120, 10, 100, 20);
                    btn_cancel_.caption(STR("Cancel"));
                    btn_cancel_.events().click(*this, &amp;example::_m_cancel);
                    prog_.create(*this, 10, 40, 280, 20);
                    this-&gt;make_event&lt;nana::events::unload&gt;(*this, &amp;example::_m_cancel);
            }
     private:
            void _m_start()
            {
                    working_ = true;
                    btn_start_.enabled(false);
                    prog_.amount(100);
                    for(int i = 0; i &lt; 100 &amp;&amp; working_; ++i)
                    {
                            nana::system::sleep(1000); //a long-running simulation
                            prog_.value(i + 1);
                    }
                    btn_start_.enabled(true);
            }
            void _m_cancel()
            {
                    working_ = false;
            }
            private:
            volatile bool working_;
            nana::button btn_start_;
            nana::button btn_cancel_;
            nana::progressbar prog_;
            nana::threads::pool pool_;
    };

    int main()
    {
            example ex;
            ex.show();
            nana::exec();
            return 0;
    }
</pre><div class="image">
<img src="../../long-running2.jpg" alt="long-running2.jpg"/>
</div>
<p>The Nana C++ Library provides a threadpool class. To solute this problem, threadpool can help developer to get rid of thread managment, such as, how to create thread? how to wait for a thread finish? and so on. Compare these tow pieces of code, they are very close, but the most important difference between these tow pieces of code is <code>_m_start()</code> is dispatched to the threadpool and execute in a background thread, the UI thread is not blocking and free to accept new events.</p>
<p>There is a function named pool_push, it creates a pool_pusher function object to push the <code>_m_start()</code> into threadpool. Registering the pool_pusher function object as a button event, the pool_pusher function object will be called to push the <code>_m_start()</code> as a task into threadpool while clicking on the button.</p>
<p>In this version, the form makes an unload event also calling <code>_m_cancel()</code>, when closes the form, the application drops the rest of operations. But there is one question need to be answered, when the long-running operation is working, closing the form will closes the buttons and progressbar, and at the same time, the long-running operation is not finish synchronous, will crash the application when long-running operation calls methods of button and progressbar after closing the form? The anwser is YES, but the code above avoid the destruction of button and progressbar before the finish of <code>_m_start()</code>, the threadpool is defined following buttons and progressbar, this means the threadpool is destructed before the button and the progressbar, when destruct the threadpool, it waits until all worker thread is finish.</p>
<p>Handling a blocking operation with a background thread.</p>
<p>A long time blocking operation is usually uncancellable and not able to get the progress of process. In this situation, application usually updates UI to indicate it is working. </p>
<pre class="fragment">    #include &lt;nana/gui/wvl.hpp&gt;
    #include &lt;nana/gui/widgets/button.hpp&gt;
    #include &lt;nana/gui/widgets/progressbar.hpp&gt;
    #include &lt;nana/threads/pool.hpp&gt;
    class example
    : public nana::form
    {
     public:
            example()
            {
                    btn_start_.create(*this, 10, 10, 100, 20);
                    btn_start_.caption(STR("Start"));
                    btn_start_.events().click(nana::threads::pool_push(pool_, *this, &amp;example::_m_start));
                    btn_start_.events().click(nana::threads::pool_push(pool_, *this, &amp;example::_m_ui_update));
                    prog_.create(*this, 10, 40, 280, 20);
                    prog_.style(false);
            this-&gt;make_event&lt;nana::events::unload&gt;(*this, &amp;example::_m_cancel);
            }
     private:
            void _m_start()
            {
                    btn_start_.enabled(false);
                    nana::system::sleep(10000); //a blocking simulation
                    btn_start_.enabled(true);
            }
            void _m_ui_update()
            {
                    while(btn_start_.enabled() == false)
                    {
                            prog_.inc();
                            nana::system::sleep(100);
                    }
            }
            void _m_cancel(const nana::eventinfo&amp; ei)
            {
                    if(false == btn_start_.enabled())
                    ei.unload.cancel = true;
            }
     private:
            nana::button btn_start_;
            nana::progressbar prog_;
            nana::threads::pool pool_;
    };

    int main()
    {
    example ex;
    ex.show();
    nana::exec();
    return 0;
    }
</pre><div class="image">
<img src="../../long-running3.jpg" alt="long-running3.jpg"/>
</div>
<p>When click on the start button, application pushs <code>_m_start()</code> and <code>_m_ui_update()</code> into threadpool. It is very easy! </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Mar 8 2015 18:54:28 for Nana C++ Library. Reference for users. by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Nana C++ Library. Reference for users.: file_explorer.cpp</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nana C++ Library. Reference for users.
   </div>
   <div id="projectbrief">What we need to use nana</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d7/d91/file_explorer_8cpp-example.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">file_explorer.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"></div>
<div class="line"><span class="comment">// http://cpprocks.com/introduction-to-tr2-filesystem-library-in-vs2012/</span></div>
<div class="line"><span class="comment">// https://msdn.microsoft.com/en-us/library/hh874694%28v=vs.140%29.aspx      ---  C++ 14, the &lt;filesystem&gt; header VS2015</span></div>
<div class="line"><span class="comment">// https://msdn.microsoft.com/en-us/library/hh874694%28v=vs.120%29.aspx     --- &lt;filesystem&gt; header VS2013</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// test</span></div>
<div class="line"><span class="comment">//#define STD_put_time_NOT_SUPPORTED</span></div>
<div class="line"><span class="comment">//#define NANA_FILESYSTEM_FORCE</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;nana/gui/wvl.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nana/gui/widgets/panel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nana/gui/place.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nana/gui/widgets/treebox.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nana/gui/widgets/listbox.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nana/gui/widgets/categorize.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nana/gui/widgets/menubar.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nana/gui/widgets/toolbar.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nana/filesystem/filesystem_ext.hpp&gt;</span>  <span class="comment">// #include &lt;nana/filesystem/filesystem_selector.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>fs     = std::experimental::filesystem;</div>
<div class="line"><span class="keyword">namespace </span>fs_ext = nana::filesystem_ext;</div>
<div class="line"></div>
<div class="line"><span class="comment">//inline directory_only_iterator children(const fs::directory_entry&amp; f) { return directory_only_iterator{ f.path() }; }</span></div>
<div class="line"><span class="comment">//inline fs::directory_iterator  l_items (const fs::directory_entry&amp; f) { return fs::directory_iterator { f.path() }; }</span></div>
<div class="line"><span class="comment">//inline std::string             f_name  (const fs::directory_entry&amp; f) { return f.path().filename().generic_u8string(); }</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// the following types could be converted into types parametrs for a generic treelistpathview explorer</span></div>
<div class="line"><span class="keyword">using</span> d_node            = fs::directory_entry ;</div>
<div class="line"><span class="keyword">using</span> d_item            = fs::directory_entry ;</div>
<div class="line"><span class="keyword">using</span> ct_n_children     = <a name="_a0"></a><a class="code" href="../../d2/d5e/classnana_1_1filesystem__ext_1_1directory__only__iterator.html">fs_ext::directory_only_iterator</a>;</div>
<div class="line"><span class="keyword">using</span> ct_l_items        = fs::directory_iterator ;</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> children = [](<span class="keyword">const</span> d_node&amp; f)-&gt;ct_n_children<span class="comment">//&amp; </span></div>
<div class="line">                                { </div>
<div class="line">                                        <span class="keywordflow">return</span> ct_n_children{ f.path() };</div>
<div class="line">                                };   <span class="comment">// ct_n_children&amp; f1(const d_node&amp;);</span></div>
<div class="line"><span class="keyword">auto</span> l_items  = [](<span class="keyword">const</span> d_node&amp; f)-&gt;ct_l_items<span class="comment">//&amp;    </span></div>
<div class="line">                                { </div>
<div class="line">                                        <span class="keywordflow">return</span> ct_l_items   { f.path() };</div>
<div class="line">                                };   <span class="comment">// ct_l_items&amp;  f2(const d_node&amp;);</span></div>
<div class="line"><span class="keyword">auto</span> f_name   = [](<span class="keyword">const</span> d_node&amp; f) </div>
<div class="line">                                { </div>
<div class="line">                                        <span class="keywordflow">return</span>  f.path().filename().generic_u8string(); </div>
<div class="line">                                };     <span class="comment">// std::string  f3(const d_node&amp;);</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> f_node_children = decltype (children);</div>
<div class="line"><span class="keyword">using</span> f_list_items    = decltype (l_items);</div>
<div class="line"><span class="keyword">using</span> f_node_title    = decltype (f_name);</div>
<div class="line"></div>
<div class="line"><a name="_a1"></a><a class="code" href="../../d0/d3c/classnana_1_1drawerbase_1_1listbox_1_1oresolver.html">nana::listbox::oresolver</a>&amp; operator&lt;&lt;(<a class="code" href="../../d0/d3c/classnana_1_1drawerbase_1_1listbox_1_1oresolver.html">nana::listbox::oresolver</a>&amp; ores, <span class="keyword">const</span> d_node&amp; item)</div>
<div class="line">{</div>
<div class="line">        ores &lt;&lt; f_name(item);</div>
<div class="line">    ores &lt;&lt; <a class="code" href="../../d2/d5a/namespacenana_1_1filesystem__ext.html#a16f589a3d74c38dfe07968d092f3dfc0">fs_ext::pretty_file_date</a>(item);<span class="comment">//.path()</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (fs::is_directory(item))</div>
<div class="line">                ores &lt;&lt; (<span class="stringliteral">&quot;Directory&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">                <span class="keywordflow">if</span> (item.path().has_extension())</div>
<div class="line">                        ores &lt;&lt; item.path().extension();</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                        ores &lt;&lt; (<span class="stringliteral">&quot;File&quot;</span>);</div>
<div class="line"></div>
<div class="line">        ores &lt;&lt; <a class="code" href="../../d2/d5a/namespacenana_1_1filesystem__ext.html#a5ca1ec17fd5a07ca11392b2eef836c0c">fs_ext::pretty_file_size</a>(item);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> ores;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a name="_a2"></a><a class="code" href="../../d6/d05/classnana_1_1drawerbase_1_1listbox_1_1iresolver.html">nana::listbox::iresolver</a>&amp; operator&gt;&gt;(<a class="code" href="../../d6/d05/classnana_1_1drawerbase_1_1listbox_1_1iresolver.html">nana::listbox::iresolver</a>&amp; ires, d_node&amp; m)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/*std::string  type;</span></div>
<div class="line"><span class="comment">        ires &gt;&gt; m.name &gt;&gt; type &gt;&gt; type;</span></div>
<div class="line"><span class="comment">        m.directory = (type == &quot;Directory&quot;);*/</span></div>
<div class="line">        <span class="keywordflow">return</span> ires;</div>
<div class="line">}</div>
<div class="line"><span class="comment">//template &lt;class d_node, </span></div>
<div class="line"><span class="comment">//            class d_item = d_node::value_type,</span></div>
<div class="line"><span class="comment">//                class ctn_node_children = std::vector&lt;d_node&gt;&amp; F(d_node&amp;) ,</span></div>
<div class="line"><span class="comment">//                class ctn_list_items    = std::vector&lt;d_item&gt;&amp; F(d_node&amp;) ,</span></div>
<div class="line"><span class="comment">//                class ft_node_title = std::string /* title_to_node */(const d_node::value_type&amp; value)</span></div>
<div class="line"><span class="comment">//         &gt;   // some data_node -like template</span></div>
<div class="line"><span class="keyword">class </span>explorer :<span class="keyword">public</span> <a name="_a3"></a><a class="code" href="../../d6/d57/classnana_1_1form.html">nana::form</a></div>
<div class="line">{</div>
<div class="line">        <a name="_a4"></a><a class="code" href="../../dc/de3/classnana_1_1place.html">nana::place</a>                place_ {*<span class="keyword">this</span>};</div>
<div class="line">        <a name="_a5"></a><a class="code" href="../../da/de1/classnana_1_1treebox.html">nana::treebox</a>          tree_  {*<span class="keyword">this</span>};</div>
<div class="line">        <a name="_a6"></a><a class="code" href="../../d1/dda/classnana_1_1listbox.html">nana::listbox</a>          list_  {*<span class="keyword">this</span>};</div>
<div class="line">        <a name="_a7"></a><a class="code" href="../../d5/d30/classnana_1_1categorize.html">nana::categorize&lt;d_node&gt;</a> path_  {*<span class="keyword">this</span>};</div>
<div class="line">        <a name="_a8"></a><a class="code" href="../../d3/dc0/classnana_1_1menubar.html">nana::menubar</a>          menu_  {*<span class="keyword">this</span>};</div>
<div class="line">        <a name="_a9"></a><a class="code" href="../../d1/d87/classnana_1_1panel.html">nana::panel&lt;false&gt;</a>     view_  {*<span class="keyword">this</span>},</div>
<div class="line">                               status_{*<span class="keyword">this</span>};</div>
<div class="line">        <a name="_a10"></a><a class="code" href="../../dc/d3d/classnana_1_1toolbar.html">nana::toolbar</a>          tools_ {*<span class="keyword">this</span>},</div>
<div class="line">                               nav_   {*<span class="keyword">this</span>};</div>
<div class="line"></div>
<div class="line">        f_node_title           &amp;node_to_title;</div>
<div class="line">        f_node_children        &amp;node_children;</div>
<div class="line">        f_list_items           &amp;list_items;</div>
<div class="line"></div>
<div class="line">        <a name="_a11"></a><a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>            div_    =</div>
<div class="line">                R<span class="stringliteral">&quot;(
                                vertical &lt;weight=23 menu&gt;
                         &lt;weight=23 path&gt;
                         &lt;weight=23 tools&gt;
                                         &lt;&lt;tree&gt; |70%   &lt; vertical &lt;list&gt; |50%  &lt;vertical &lt;weight=23 nav&gt;
                                                                          &lt;view&gt;  
                                                                &gt; 
                                         &gt; 
                         &gt;
                         &lt;weight=23 status&gt;  
           )&quot;;</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span><span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">bool</span>                               force_refresh{<span class="keyword">false</span>};</div>
<div class="line">        <a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>            fake_item;<span class="comment">// { &quot;Sorry, this is a fake item!&quot; }; //workaround for VC2013 error C2797: &#39;explorer::fake_item&#39;: list initialization inside member initializer list or non-static data member initializer is not implemented</span></div>
<div class="line"></div>
<div class="line">        <span class="keyword">using</span> t_node = <a name="a12"></a><a class="code" href="../../da/de1/classnana_1_1treebox.html#a38932561c58a77ff473619e20c3329b9">nana::treebox::item_proxy</a>;</div>
<div class="line">        explorer ( <span class="comment">/*d_node&amp; root,*/</span> </div>
<div class="line">                       f_node_title     fnt,</div>
<div class="line">                       f_node_children  ctnc,</div>
<div class="line">                       f_list_items     ctni,</div>
<div class="line">                       <a name="_a13"></a><a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a name="_a14"></a><a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;std::string, unsigned&gt;</a>&gt; columns,</div>
<div class="line">                       <a name="_a15"></a><a class="code" href="../../dd/d2d/structnana_1_1rectangle.html">nana::rectangle</a> r= <a class="code" href="../../dd/d2d/structnana_1_1rectangle.html">nana::rectangle</a>{ <a name="_a16"></a><a class="code" href="../../de/da3/structnana_1_1basic__point.html">nana::point</a>{50,10}, <a name="_a17"></a><a class="code" href="../../da/df8/structnana_1_1size.html">nana::size</a>{900,600} },</div>
<div class="line">                       <a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> title={} )</div>
<div class="line">        :form{r}, node_to_title{fnt}, node_children{ ctnc }, list_items{ ctni }, fake_item(<span class="stringliteral">&quot;Sorray, this is a fake item&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">                place_.div(div_.c_str());</div>
<div class="line">                place_[<span class="stringliteral">&quot;menu&quot;</span>]  &lt;&lt; menu_ ;</div>
<div class="line">                place_[<span class="stringliteral">&quot;tools&quot;</span>] &lt;&lt; tools_ ;</div>
<div class="line">                place_[<span class="stringliteral">&quot;path&quot;</span>]  &lt;&lt; path_ ;</div>
<div class="line">                place_[<span class="stringliteral">&quot;tree&quot;</span>]  &lt;&lt; tree_ ;</div>
<div class="line">                place_[<span class="stringliteral">&quot;list&quot;</span>]  &lt;&lt; list_ ;</div>
<div class="line">                place_[<span class="stringliteral">&quot;nav&quot;</span>]   &lt;&lt; nav_ ;</div>
<div class="line">                place_[<span class="stringliteral">&quot;view&quot;</span>]  &lt;&lt; view_ ;</div>
<div class="line">                place_[<span class="stringliteral">&quot;status&quot;</span>]&lt;&lt; status_ ;</div>
<div class="line">                place_.collocate();</div>
<div class="line"></div>
<div class="line">                <span class="comment">//t_node tree_root = add_root(root);</span></div>
<div class="line">                tree_.events().<a name="a18"></a><a class="code" href="../../d5/d96/classnana_1_1drawerbase_1_1treebox_1_1item__proxy.html#a1d8f408f6ceda111c6bd053b141c6f95">selected</a>( [<span class="keyword">this</span>](<span class="keyword">const</span> <a name="_a19"></a><a class="code" href="../../df/df9/structnana_1_1arg__treebox.html">nana::arg_treebox</a> &amp;tb_msg)</div>
<div class="line">                                                                 { </div>
<div class="line">                                                                        <span class="keywordflow">if</span> (!tb_msg.<a name="a20"></a><a class="code" href="../../df/df9/structnana_1_1arg__treebox.html#ad8e07298693767fbb840d04eefb20ce5">operated</a>  ) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">                                            <span class="comment">//d_node d{ tree_.make_key_path(tb_msg.item, &quot;/&quot; /*nana::to_utf8(fs::path::preferred_separator)*/ ) </span></div>
<div class="line">                                                                        <span class="comment">//              + &quot;/&quot; /*d_node::separator*/ };</span></div>
<div class="line">                                                                        </div>
<div class="line">                                                                        tree_.auto_draw(<span class="keyword">false</span>);</div>
<div class="line">                                                                        list_.auto_draw(<span class="keyword">false</span>);</div>
<div class="line">                                                                        <span class="comment">//path_.auto_draw(false);</span></div>
<div class="line"></div>
<div class="line">                                                                        refresh_tnode(tb_msg.<a name="a21"></a><a class="code" href="../../df/df9/structnana_1_1arg__treebox.html#ace88bdf3df5a36d0405f625648f96a4f">item</a>,      force_refresh);</div>
<div class="line">                                                                        refresh_list(tb_msg.<a class="code" href="../../df/df9/structnana_1_1arg__treebox.html#ace88bdf3df5a36d0405f625648f96a4f">item</a>);</div>
<div class="line">                                                                        refresh_path(tb_msg.<a class="code" href="../../df/df9/structnana_1_1arg__treebox.html#ace88bdf3df5a36d0405f625648f96a4f">item</a>);</div>
<div class="line">        </div>
<div class="line">                                                                        tree_.auto_draw(<span class="keyword">true</span>);</div>
<div class="line">                                                                        list_.auto_draw(<span class="keyword">true</span>);</div>
<div class="line">                                                                        <span class="comment">//path_.auto_draw(true);</span></div>
<div class="line">                                                                 });</div>
<div class="line"></div>
<div class="line">                tree_.events().expanded([<span class="keyword">this</span>](<span class="keyword">const</span> <a class="code" href="../../df/df9/structnana_1_1arg__treebox.html">nana::arg_treebox</a> &amp;tb_msg)</div>
<div class="line">                                                                {</div>
<div class="line">                                                                        tree_.auto_draw(<span class="keyword">false</span>);</div>
<div class="line">                                                                        refresh_tnode(tb_msg.<a class="code" href="../../df/df9/structnana_1_1arg__treebox.html#ace88bdf3df5a36d0405f625648f96a4f">item</a>, force_refresh);</div>
<div class="line">                                                                        tree_.auto_draw(<span class="keyword">true</span>);</div>
<div class="line">                                                                });</div>
<div class="line"></div>
<div class="line">                <span class="comment">//tree_root.select(true)  ;</span></div>
<div class="line">                menu_.push_back(<span class="stringliteral">&quot;File&quot;</span>);</div>
<div class="line">                menu_.push_back(<span class="stringliteral">&quot;Help&quot;</span>);</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; col : columns)</div>
<div class="line">                        list_.append_header(col.first, col.second);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        t_node add_root(d_node &amp; root)</div>
<div class="line">        {</div>
<div class="line">                <span class="keyword">auto</span> r= tree_.insert(node_to_title(root), node_to_title(root));</div>
<div class="line">                r.value(root);</div>
<div class="line">                signal_child(r);</div>
<div class="line">                <span class="keywordflow">return</span> r;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        t_node add_root(<a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp; root)</div>
<div class="line">        {</div>
<div class="line">                <span class="keyword">auto</span> r = tree_.insert(root, root);</div>
<div class="line">                r.value(d_node(root));</div>
<div class="line">                signal_child(r);</div>
<div class="line">                <span class="keywordflow">return</span> r;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        t_node add_root(<a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> k, <a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> t, d_node &amp;&amp; root)   <span class="comment">// revise ref types</span></div>
<div class="line">        {</div>
<div class="line">                <span class="keyword">auto</span> r = tree_.insert(k, t);</div>
<div class="line">                r.value(root);</div>
<div class="line">                signal_child(r);</div>
<div class="line">                <span class="keywordflow">return</span> r;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> signal_child(t_node&amp; node)</div>
<div class="line">        {</div>
<div class="line">                <span class="keywordflow">if</span> (!force_refresh &amp;&amp; !node.child().empty()) <span class="keywordflow">return</span>;</div>
<div class="line">                clear_children(node);</div>
<div class="line">                <span class="keyword">auto</span>&amp; <a class="code" href="../../dc/d5e/namespacenana_1_1widgets_1_1skeletons.html#a15b3bae04116a938253c00cb951caccda8d777f385d3dfec8815d20f7496026dc">data</a> = node.value&lt;d_node&gt;();</div>
<div class="line">                <span class="keyword">const</span> ct_n_children&amp; d_c = node_children(data);</div>
<div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>&amp; child_1 = <a name="a22"></a><a class="code" href="../../d2/d76/namespacenana.html#a1480f163a64163d468bcdd3d8dd16c25a8d589afa4dfaeeed85fff5aa78e5ff6a">begin</a>(d_c);</div>
<div class="line">                <span class="keywordflow">if</span> (child_1 != <a name="a23"></a><a class="code" href="../../d2/d76/namespacenana.html#a1480f163a64163d468bcdd3d8dd16c25a7f021a1415b86f2d013b2618fb31ae53">end</a>(d_c))</div>
<div class="line">                        tree_.insert(node, fake_item, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> clear_children(t_node&amp; sel_node)</div>
<div class="line">        {</div>
<div class="line">                <span class="keywordflow">while</span> (!sel_node.child().empty())</div>
<div class="line">                        tree_.erase(sel_node.child());</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span>  refresh_list(t_node&amp; sel_node)</div>
<div class="line">        {</div>
<div class="line">                list_.clear();</div>
<div class="line">                <span class="keyword">const</span> ct_l_items&amp; items = list_items(sel_node.value&lt;d_node&gt;());</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;i : items) </div>
<div class="line">                        list_.at(0).append(i, <span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span>  refresh_path(t_node&amp; sel_node) {};</div>
<div class="line">        <span class="keywordtype">void</span>  refresh_tnode(t_node&amp; sel_node, <span class="keywordtype">bool</span> force)</div>
<div class="line">        {</div>
<div class="line">                <span class="keywordflow">if</span> (!force &amp;&amp; !sel_node.child().empty() &amp;&amp; sel_node.child().key()!=fake_item ) <span class="keywordflow">return</span>;</div>
<div class="line">                clear_children(sel_node);</div>
<div class="line">                <span class="keyword">const</span> ct_n_children&amp; d_c = node_children(sel_node.value&lt;d_node&gt;());</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;n : d_c) </div>
<div class="line">                {</div>
<div class="line">                        <span class="keyword">auto</span> name = node_to_title(n);</div>
<div class="line">                        <span class="keyword">auto</span> tn = tree_.insert(sel_node, name, name);</div>
<div class="line">                        <span class="keywordflow">if</span> (tn.empty()) <span class="keywordflow">continue</span>;</div>
<div class="line">                        tn.value(n);</div>
<div class="line">                        signal_child(tn);</div>
<div class="line">                }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//using file_explorer_t = explorer&lt; fs::directory_entry,   ///&lt; d_node</span></div>
<div class="line"><span class="comment">//                                    fs::directory_entry,   ///&lt; d_item</span></div>
<div class="line"><span class="comment">//                                                                decltype (children),   ///&lt; ctn_node_children</span></div>
<div class="line"><span class="comment">//                                    decltype (l_items),        ///&lt; ctn_list_items</span></div>
<div class="line"><span class="comment">//                                    decltype (f_name)      ///&lt; ft_node_title</span></div>
<div class="line"><span class="comment">//                                &gt;;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The model / data known how to build a data_node from the path or from the value in the d_node atached to the t_node.</span></div>
<div class="line"><span class="comment">// The tree know how to build the path, and how to build a t_node from d_node</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//using namespace nana;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> dir_it = <a class="code" href="../../d2/d5e/classnana_1_1filesystem__ext_1_1directory__only__iterator.html">fs_ext::directory_only_iterator</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class </span>V,</div>
<div class="line"><span class="keyword">class </span>C_I, </div>
<div class="line"><span class="keyword">class </span>C_N  </div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">struct </span>data_node</div>
<div class="line">{</div>
<div class="line">        <span class="keyword">using</span> value_type = V;</div>
<div class="line">        <span class="keyword">using</span> cont_it_t = C_I;</div>
<div class="line">        <span class="keyword">using</span> cont_nd_t = C_I;</div>
<div class="line"></div>
<div class="line">        value_type   value;</div>
<div class="line">        C_I          items;   <span class="comment">// any oder container of value_type with begin, end, != and ++() </span></div>
<div class="line">        C_N          nodes;   <span class="comment">// any oder container of data_node  with begin, end, != and ++() </span></div>
<div class="line">        <a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>  separator;</div>
<div class="line"></div>
<div class="line">        data_node(<a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> path, <a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>  separator = <span class="stringliteral">&quot;/&quot;</span>)</div>
<div class="line">                : value{ path },</div>
<div class="line">                separator(separator)<span class="comment">/*,</span></div>
<div class="line"><span class="comment">                                                        items{ path },</span></div>
<div class="line"><span class="comment">                                                        nodes{ path }*/</span> {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// &quot;globals functions&quot;</span></div>
<div class="line"><a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>            key(<span class="comment">/* value_type*/</span>) { <span class="keywordflow">return</span>{}; };</div>
<div class="line"><a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>            title(<span class="comment">/* value_type*/</span>) { <span class="keywordflow">return</span>{}; };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>dir_node</div>
<div class="line">{</div>
<div class="line">        <span class="keyword">using</span> value_type = fs::directory_entry;</div>
<div class="line">        <span class="keyword">using</span> cont_it_t = fs::directory_iterator;</div>
<div class="line">        <span class="keyword">using</span> cont_nd_t = <a class="code" href="../../d2/d5e/classnana_1_1filesystem__ext_1_1directory__only__iterator.html">fs_ext::directory_only_iterator</a>;</div>
<div class="line"></div>
<div class="line">        value_type     value;</div>
<div class="line">        cont_it_t      items;</div>
<div class="line">        cont_nd_t      nodes;</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> separator;</div>
<div class="line"></div>
<div class="line">        dir_node(fs::path path)</div>
<div class="line">                : value{ path }, items{ path }, nodes { path }</div>
<div class="line">        {}</div>
<div class="line">                <span class="comment">//separator{ &quot;/&quot;  },     /*  std::experimental::filesystem::path::preferred_separator  */</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">};</div>
<div class="line"><span class="keyword">const</span> <a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> dir_node::separator{ <span class="stringliteral">&quot;/&quot;</span> };</div>
<div class="line"></div>
<div class="line"><span class="comment">//struct d_node : data_node&lt;std::experimental::filesystem::directory_entry, </span></div>
<div class="line"><span class="comment">//                            std::experimental::filesystem::directory_entry,</span></div>
<div class="line"><span class="comment">//                            directory_only_iterator&gt; </span></div>
<div class="line"><span class="comment">//{</span></div>
<div class="line"><span class="comment">//      using B_T = data_node&lt;std::experimental::filesystem::directory_entry,</span></div>
<div class="line"><span class="comment">//                                std::experimental::filesystem::directory_entry,</span></div>
<div class="line"><span class="comment">//                                directory_only_iterator&gt;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      dir_node(std::experimental::filesystem::path path)</span></div>
<div class="line"><span class="comment">//              : B_T{ path }</span></div>
<div class="line"><span class="comment">//      { </span></div>
<div class="line"><span class="comment">//              dir{ path },</span></div>
<div class="line"><span class="comment">//              nodes{ path } {}</span></div>
<div class="line"><span class="comment">//};</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>            key(<span class="keyword">const</span> dir_node&amp; dn) { <span class="keywordflow">return</span> dn.value.path().filename().generic_u8string(); };</div>
<div class="line"><a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>            title(<span class="keyword">const</span> dir_node&amp; dn) { <span class="keywordflow">return</span> key(dn); };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>            key(<span class="keyword">const</span> dir_it&amp; d) { <span class="keywordflow">return</span> d-&gt;path().filename().generic_u8string(); };</div>
<div class="line"><a class="codeRef" doxygen="C:/Prog/ExtLib/nana-docs/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w//" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>            title(<span class="keyword">const</span> dir_it&amp; d) { <span class="keywordflow">return</span> key(d); };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//template &lt;class it&gt;</span></div>
<div class="line"><span class="comment">//struct data_it</span></div>
<div class="line"><span class="comment">//{</span></div>
<div class="line"><span class="comment">//      std::vector&lt;it&gt; items;</span></div>
<div class="line"><span class="comment">//      std::vector&lt;data_node&gt; nodes;</span></div>
<div class="line"><span class="comment">//};</span></div>
<div class="line"><span class="comment">//template &lt;class value&gt;</span></div>
<div class="line"><span class="comment">//using title_node = std::string /* title_to_node */ (const value&amp; node_value);</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//class file_explorer   : public nana::form</span></div>
<div class="line"><span class="comment">//{</span></div>
<div class="line"><span class="comment">//         public:      using  item_proxy = nana::treebox::item_proxy ;</span></div>
<div class="line"><span class="comment">//                  enum class kind {none, filesystem};     </span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// private:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      nana::place             place_  {*this};</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    nana::button          btn_new_folder_ {*this, &quot;&amp;New Folder&quot; };</span></div>
<div class="line"><span class="comment">//    nana::categorize&lt;int&gt; path_ {*this};</span></div>
<div class="line"><span class="comment">//      nana::treebox       tree_   {*this};</span></div>
<div class="line"><span class="comment">//      nana::listbox       ls_file_{*this};</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      nana::textbox           filter_ {*this};</span></div>
<div class="line"><span class="comment">//      nana::combox        cb_types_ {*this};</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      nana::label         lb_file_  {*this, &quot;File:&quot; };</span></div>
<div class="line"><span class="comment">//      nana::textbox       tb_file_  {*this};</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      //nana::button        btn_ok_,    btn_cancel_;</span></div>
<div class="line"><span class="comment">//    //bool                io_read_;</span></div>
<div class="line"><span class="comment">//      //nana::string        def_ext_;</span></div>
<div class="line"><span class="comment">//public:</span></div>
<div class="line"><span class="comment">//      struct item_fs</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              std::string  name;</span></div>
<div class="line"><span class="comment">//              tm            modified_time;</span></div>
<div class="line"><span class="comment">//              bool          directory;</span></div>
<div class="line"><span class="comment">//              uintmax_t     bytes;       // nana::long_long_t</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              friend nana::listbox::iresolver&amp; operator&gt;&gt;(nana::listbox::iresolver&amp; ires, item_fs&amp; m)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      std::string  type;</span></div>
<div class="line"><span class="comment">//                      ires &gt;&gt; m.name &gt;&gt; type &gt;&gt; type ;</span></div>
<div class="line"><span class="comment">//                      m.directory = (type == &quot;Directory&quot;);</span></div>
<div class="line"><span class="comment">//                      return ires;</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              friend nana::listbox::oresolver&amp; operator&lt;&lt;(nana::listbox::oresolver&amp; ores, const item_fs&amp; item)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      std::stringstream tm;</span></div>
<div class="line"><span class="comment">//                      tm &lt;&lt; (item.modified_time.tm_year + 1900) &lt;&lt; &#39;-&#39; ;</span></div>
<div class="line"><span class="comment">//                      _m_add(tm, item.modified_time.tm_mon + 1) &lt;&lt; &#39;-&#39; ;</span></div>
<div class="line"><span class="comment">//                      _m_add(tm, item.modified_time.tm_mday )   &lt;&lt; &#39; &#39; ;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      _m_add(tm, item.modified_time.tm_hour )   &lt;&lt; &#39;:&#39; ;</span></div>
<div class="line"><span class="comment">//                      _m_add(tm, item.modified_time.tm_min  )   &lt;&lt; &#39;:&#39; ;</span></div>
<div class="line"><span class="comment">//                      _m_add(tm, item.modified_time.tm_sec  )   ;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      ores&lt;&lt;item.name&lt;&lt;tm.str();</span></div>
<div class="line"><span class="comment">//                      if(!item.directory)</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              auto pos = item.name.find_last_of((&#39;.&#39;));</span></div>
<div class="line"><span class="comment">//                              if(pos != item.name.npos &amp;&amp; (pos + 1 &lt; item.name.size()))</span></div>
<div class="line"><span class="comment">//                                      ores&lt;&lt;item.name.substr(pos + 1);</span></div>
<div class="line"><span class="comment">//                              else</span></div>
<div class="line"><span class="comment">//                                      ores&lt;&lt;(&quot;File&quot;);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                              ores&lt;&lt;_m_trans(item.bytes);</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//                      else</span></div>
<div class="line"><span class="comment">//                              ores&lt;&lt;(&quot;Directory&quot;);</span></div>
<div class="line"><span class="comment">//                      return ores;</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      private:</span></div>
<div class="line"><span class="comment">//              static std::stringstream&amp; _m_add(std::stringstream&amp; ss, unsigned v)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      if(v &lt; 10)</span></div>
<div class="line"><span class="comment">//                              ss&lt;&lt;&#39;0&#39;;</span></div>
<div class="line"><span class="comment">//                      ss&lt;&lt;v;</span></div>
<div class="line"><span class="comment">//                      return ss;</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              static std::string _m_trans(std::size_t bytes)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      const char * ustr[] = {&quot; KB&quot;, &quot; MB&quot;, &quot; GB&quot;, &quot; TB&quot;};</span></div>
<div class="line"><span class="comment">//                      std::stringstream ss;</span></div>
<div class="line"><span class="comment">//                      if(bytes &gt;= 1024)</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              double cap = bytes / 1024.0;</span></div>
<div class="line"><span class="comment">//                              std::size_t uid = 0;</span></div>
<div class="line"><span class="comment">//                              while((cap &gt;= 1024.0) &amp;&amp; (uid &lt; sizeof(ustr)/sizeof(char *)))</span></div>
<div class="line"><span class="comment">//                              {</span></div>
<div class="line"><span class="comment">//                                      cap /= 1024.0;</span></div>
<div class="line"><span class="comment">//                                      ++uid;</span></div>
<div class="line"><span class="comment">//                              }</span></div>
<div class="line"><span class="comment">//                              ss&lt;&lt;cap;</span></div>
<div class="line"><span class="comment">//                              auto s = ss.str();</span></div>
<div class="line"><span class="comment">//                              auto pos = s.find(&#39;.&#39;);</span></div>
<div class="line"><span class="comment">//                              if(pos != s.npos)</span></div>
<div class="line"><span class="comment">//                              {</span></div>
<div class="line"><span class="comment">//                                      if(pos + 2 &lt; s.size())</span></div>
<div class="line"><span class="comment">//                                              s.erase(pos + 2);</span></div>
<div class="line"><span class="comment">//                              }</span></div>
<div class="line"><span class="comment">//                              return s + ustr[uid];</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//                      ss&lt;&lt;bytes&lt;&lt;&quot; Bytes&quot;;</span></div>
<div class="line"><span class="comment">//                      return ss.str();</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//      };</span></div>
<div class="line"><span class="comment">//      </span></div>
<div class="line"><span class="comment">//    std::vector&lt;item_fs&gt; file_container_;</span></div>
<div class="line"><span class="comment">//      struct path_tag</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              std::string filesystem;</span></div>
<div class="line"><span class="comment">//      }     addr_;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      struct selection_tag</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              kind type;</span></div>
<div class="line"><span class="comment">//              std::string target;</span></div>
<div class="line"><span class="comment">//      }    selection_;</span></div>
<div class="line"><span class="comment">//      </span></div>
<div class="line"><span class="comment">//      struct tree_node_tag</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              item_proxy home;</span></div>
<div class="line"><span class="comment">//              item_proxy filesystem;</span></div>
<div class="line"><span class="comment">//      }nodes_;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      static std::string saved_init_path;</span></div>
<div class="line"><span class="comment">//      static std::string saved_selected_path;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      struct pred_sort_fs</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              bool operator()(const item_fs&amp; a, const item_fs&amp; b) const</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      return ((a.directory != b.directory) &amp;&amp; a.directory);</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//      };</span></div>
<div class="line"><span class="comment">//public:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      file_explorer( const std::string&amp; title= &quot;Nana File Explorer&quot;)  : form( nana::API::make_center( 630, 440) )</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              path_.splitstr(&quot;/&quot;);</span></div>
<div class="line"><span class="comment">//              path_.events().selected.connect_unignorable([this](const nana::arg_categorize&lt;int&gt;&amp;)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      auto path = path_.caption();</span></div>
<div class="line"><span class="comment">//                      auto root = path.substr(0, path.find((&#39;/&#39;)));</span></div>
<div class="line"><span class="comment">//                      if(root ==  (&quot;HOME&quot;))</span></div>
<div class="line"><span class="comment">//                              path.replace(0, 4, def_rootname);//nana::experimental::filesystem::path_user());   //  REPLACE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! to filesystem_ext.hhp</span></div>
<div class="line"><span class="comment">//                      else if(root == (&quot;FILESYSTEM&quot;))</span></div>
<div class="line"><span class="comment">//                              path.erase(0, 10);</span></div>
<div class="line"><span class="comment">//                      else</span></div>
<div class="line"><span class="comment">//                              throw std::runtime_error(&quot;Nana.GUI.Filebox: Wrong categorize path&quot;);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      if(path.size() == 0) path = (&quot;/&quot;);</span></div>
<div class="line"><span class="comment">//                      _m_load_cat_path(path);</span></div>
<div class="line"><span class="comment">//              });</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              btn_new_folder_.events().click.connect_unignorable([this](const nana::arg_click&amp;)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//              // use inputbox</span></div>
<div class="line"><span class="comment">//                      nana::form fm(this-&gt;handle(), nana::API::make_center(*this, 300, 35));</span></div>
<div class="line"><span class="comment">//                      fm.caption((&quot;Name the new folder&quot;));</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      nana::textbox folder(fm, nana::rectangle(5, 5, 160, 25));</span></div>
<div class="line"><span class="comment">//                      folder.multi_lines(false);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      nana::button btn(fm, nana::rectangle(170, 5, 60, 25));</span></div>
<div class="line"><span class="comment">//                      btn.caption((&quot;Create&quot;));</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      btn.events().click.connect_unignorable(folder_creator(*this, fm, folder));</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      nana::button btn_cancel(fm, nana::rectangle(235, 5, 60, 25));</span></div>
<div class="line"><span class="comment">//                      btn_cancel.caption((&quot;Cancel&quot;));</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      btn_cancel.events().click.connect_unignorable([&amp;fm](const nana::arg_click&amp;)</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              fm.close();</span></div>
<div class="line"><span class="comment">//                      });</span></div>
<div class="line"><span class="comment">//                      nana::API::modal_window(fm);</span></div>
<div class="line"><span class="comment">//              });</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              ls_file_.append_header((&quot;Name&quot;    ), 190);</span></div>
<div class="line"><span class="comment">//              ls_file_.append_header((&quot;Modified&quot;), 145);</span></div>
<div class="line"><span class="comment">//              ls_file_.append_header((&quot;Type&quot;    ),  80);</span></div>
<div class="line"><span class="comment">//              ls_file_.append_header((&quot;Size&quot;    ),  70);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              auto fn_sel_file = [this](const nana::arg_mouse&amp; arg){  _m_sel_file(arg);               };</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              ls_file_.events().dbl_click .connect_unignorable(fn_sel_file);</span></div>
<div class="line"><span class="comment">//              ls_file_.events().mouse_down.connect_unignorable(fn_sel_file);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              ls_file_.set_sort_compare(0, [](const std::string&amp; a, nana::any* fs_a,</span></div>
<div class="line"><span class="comment">//                                        const std::string&amp; b, nana::any* fs_b, bool reverse) -&gt; bool</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              int dira = nana::any_cast&lt;item_fs&gt;(fs_a)-&gt;directory ? 1 : 0;</span></div>
<div class="line"><span class="comment">//                              int dirb = nana::any_cast&lt;item_fs&gt;(fs_b)-&gt;directory ? 1 : 0;</span></div>
<div class="line"><span class="comment">//                              if(dira != dirb)</span></div>
<div class="line"><span class="comment">//                                      return (reverse ? dira &lt; dirb : dira &gt; dirb);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                              std::size_t seek_a = 0;</span></div>
<div class="line"><span class="comment">//                              std::size_t seek_b = 0;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                              while(true)</span></div>
<div class="line"><span class="comment">//                              {</span></div>
<div class="line"><span class="comment">//                                      std::size_t pos_a = a.find_first_of((&quot;0123456789&quot;), seek_a);</span></div>
<div class="line"><span class="comment">//                                      std::size_t pos_b = b.find_first_of((&quot;0123456789&quot;), seek_b);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                                      if((pos_a != a.npos) &amp;&amp; (pos_a == pos_b))</span></div>
<div class="line"><span class="comment">//                                      {</span></div>
<div class="line"><span class="comment">//                                              nana::cistring text_a = a.substr(seek_a, pos_a - seek_a).data();</span></div>
<div class="line"><span class="comment">//                                              nana::cistring text_b = b.substr(seek_b, pos_b - seek_b).data();</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                                              if(text_a != text_b)</span></div>
<div class="line"><span class="comment">//                                                      return (reverse ? text_a &gt; text_b : text_a &lt; text_b);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                                              std::size_t end_a = a.find_first_not_of((&quot;0123456789&quot;), pos_a + 1);</span></div>
<div class="line"><span class="comment">//                                              std::size_t end_b = b.find_first_not_of((&quot;0123456789&quot;), pos_b + 1);</span></div>
<div class="line"><span class="comment">//                      </span></div>
<div class="line"><span class="comment">//                                              std::string num_a = a.substr(pos_a, end_a != a.npos ? end_a - pos_a : a.npos);</span></div>
<div class="line"><span class="comment">//                                              std::string num_b = b.substr(pos_b, end_b != b.npos ? end_b - pos_b : b.npos);</span></div>
<div class="line"><span class="comment">//                      </span></div>
<div class="line"><span class="comment">//                                              if(num_a != num_b)</span></div>
<div class="line"><span class="comment">//                                              {</span></div>
<div class="line"><span class="comment">//                                                      double ai = std::stod(num_a, 0);</span></div>
<div class="line"><span class="comment">//                                                      double bi = std::stod(num_b, 0);</span></div>
<div class="line"><span class="comment">//                                                      if(ai != bi)</span></div>
<div class="line"><span class="comment">//                                                              return (reverse ? ai &gt; bi : ai &lt; bi);</span></div>
<div class="line"><span class="comment">//                                              }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                                              seek_a = end_a;</span></div>
<div class="line"><span class="comment">//                                              seek_b = end_b;</span></div>
<div class="line"><span class="comment">//                                      }</span></div>
<div class="line"><span class="comment">//                                      else</span></div>
<div class="line"><span class="comment">//                                              break;</span></div>
<div class="line"><span class="comment">//                              }</span></div>
<div class="line"><span class="comment">//                              if(seek_a == a.npos)</span></div>
<div class="line"><span class="comment">//                                      seek_a = 0;</span></div>
<div class="line"><span class="comment">//                              if(seek_b == b.npos)</span></div>
<div class="line"><span class="comment">//                                      seek_b = 0;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                              nana::cistring cia = a.data();</span></div>
<div class="line"><span class="comment">//                              nana::cistring cib = b.data();</span></div>
<div class="line"><span class="comment">//                              if(seek_a == seek_b &amp;&amp; seek_a == 0)</span></div>
<div class="line"><span class="comment">//                                      return (reverse ? cia &gt; cib : cia &lt; cib);</span></div>
<div class="line"><span class="comment">//                              return (reverse ? cia.substr(seek_a) &gt; cib.substr(seek_b) : cia.substr(seek_a) &lt; cib.substr(seek_b));</span></div>
<div class="line"><span class="comment">//                      });</span></div>
<div class="line"><span class="comment">//              ls_file_.set_sort_compare(2, [](const std::string&amp; a, nana::any* anyptr_a,</span></div>
<div class="line"><span class="comment">//                                        const std::string&amp; b, nana::any* anyptr_b, bool reverse) -&gt; bool</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              int dir1 =  nana::any_cast&lt;item_fs&gt;(anyptr_a)-&gt;directory ? 1 : 0;</span></div>
<div class="line"><span class="comment">//                              int dir2 =  nana::any_cast&lt;item_fs&gt;(anyptr_b)-&gt;directory ? 1 : 0;</span></div>
<div class="line"><span class="comment">//                              if(dir1 != dir2)</span></div>
<div class="line"><span class="comment">//                                      return (reverse ? dir1 &lt; dir2 : dir1 &gt; dir2);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                              return (reverse ? a &gt; b : a &lt; b);</span></div>
<div class="line"><span class="comment">//                      });</span></div>
<div class="line"><span class="comment">//              ls_file_.set_sort_compare(3, [this](const std::string&amp;, nana::any* anyptr_a,</span></div>
<div class="line"><span class="comment">//                                            const std::string&amp;, nana::any* anyptr_b, bool reverse) -&gt; bool</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              item_fs * fsa = nana::any_cast  &lt;item_fs&gt;(anyptr_a);</span></div>
<div class="line"><span class="comment">//                              item_fs * fsb = nana::any_cast  &lt;item_fs&gt;(anyptr_b);</span></div>
<div class="line"><span class="comment">//                              return (reverse ? fsa-&gt;bytes &gt; fsb-&gt;bytes : fsa-&gt;bytes &lt; fsb-&gt;bytes);</span></div>
<div class="line"><span class="comment">//                      });</span></div>
<div class="line"><span class="comment">//              tb_file_.multi_lines(false);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              tb_file_.events().key_char.connect_unignorable([this](const nana::arg_keyboard&amp; arg)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      if(arg.key == nana::keyboard::enter)</span></div>
<div class="line"><span class="comment">//                              _m_ok();</span></div>
<div class="line"><span class="comment">//              });</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              cb_types_.editable(false);</span></div>
<div class="line"><span class="comment">//              cb_types_.events().selected.connect_unignorable([this](const nana::arg_combox&amp;){ _m_list_fs(); });</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              selection_.type = kind::none;</span></div>
<div class="line"><span class="comment">//              _m_layout();</span></div>
<div class="line"><span class="comment">//              _m_init_tree();</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      void load_fs(const std::string&amp; init_path, const std::string&amp; init_file)</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              //Simulate the behavior like Windows7&#39;s </span></div>
<div class="line"><span class="comment">//        //lpstrInitialDir(http://msdn.microsoft.com/en-us/library/windows/desktop/ms646839%28v=vs.85%29.aspx)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              //Phase 1</span></div>
<div class="line"><span class="comment">//              std::string dir;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              auto pos = init_file.find_last_of( (&quot;\\/&quot;));</span></div>
<div class="line"><span class="comment">//              std::string file_with_path_removed = (pos != init_file.npos ? init_file.substr(pos + 1) : init_file);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              if(saved_init_path != init_path)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      if(saved_init_path.size() == 0)</span></div>
<div class="line"><span class="comment">//                              saved_init_path = init_path;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      //Phase 2: Check whether init_file contains a path</span></div>
<div class="line"><span class="comment">//                      if(file_with_path_removed == init_file)</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              //Phase 3: Check whether init_path is empty</span></div>
<div class="line"><span class="comment">//                              if(init_path.size())</span></div>
<div class="line"><span class="comment">//                                      dir = init_path;</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//                      else</span></div>
<div class="line"><span class="comment">//                              dir = init_file.substr(0, pos);</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//              else</span></div>
<div class="line"><span class="comment">//                      dir = saved_selected_path;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              _m_load_cat_path(dir.size() ? dir : def_rootname); //nana::experimental::filesystem::path_user());</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              tb_file_.caption(file_with_path_removed);                                       </span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//              </span></div>
<div class="line"><span class="comment">//      void add_filter(const std::string&amp; desc, const std::string&amp; type)</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              std::size_t i = cb_types_.the_number_of_options();</span></div>
<div class="line"><span class="comment">//              cb_types_.push_back(desc);</span></div>
<div class="line"><span class="comment">//              if(0 == i)</span></div>
<div class="line"><span class="comment">//                      cb_types_.option(0);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              std::vector&lt;std::string&gt; v;</span></div>
<div class="line"><span class="comment">//              std::size_t beg = 0;</span></div>
<div class="line"><span class="comment">//              while(true)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      auto pos = type.find( (&#39;;&#39;), beg);</span></div>
<div class="line"><span class="comment">//                      auto ext = type.substr(beg, pos == type.npos ? type.npos : pos - beg);</span></div>
<div class="line"><span class="comment">//                      auto dot = ext.find( (&#39;.&#39;));</span></div>
<div class="line"><span class="comment">//                      if((dot != ext.npos) &amp;&amp; (dot + 1 &lt; ext.size()))</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              ext.erase(0, dot + 1);</span></div>
<div class="line"><span class="comment">//                              if(ext ==  (&quot;*&quot;))</span></div>
<div class="line"><span class="comment">//                              {</span></div>
<div class="line"><span class="comment">//                                      v.clear();</span></div>
<div class="line"><span class="comment">//                                      break;</span></div>
<div class="line"><span class="comment">//                              }</span></div>
<div class="line"><span class="comment">//                              else</span></div>
<div class="line"><span class="comment">//                                      v.push_back(ext);</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//                      if(pos == type.npos)</span></div>
<div class="line"><span class="comment">//                              break;</span></div>
<div class="line"><span class="comment">//                      beg = pos + 1;</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//              if(v.size())</span></div>
<div class="line"><span class="comment">//                      cb_types_.anyobj(i, v);</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      bool file(std::string&amp; fs) const</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              if(selection_.type == kind::none)</span></div>
<div class="line"><span class="comment">//                      return false;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              auto pos = selection_.target.find_last_of( (&quot;\\/&quot;));</span></div>
<div class="line"><span class="comment">//              if(pos != selection_.target.npos)</span></div>
<div class="line"><span class="comment">//                      saved_selected_path = selection_.target.substr(0, pos);</span></div>
<div class="line"><span class="comment">//              else</span></div>
<div class="line"><span class="comment">//                      saved_selected_path.clear();</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              fs = selection_.target;</span></div>
<div class="line"><span class="comment">//              return true;</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//private:</span></div>
<div class="line"><span class="comment">//      void _m_layout()</span></div>
<div class="line"><span class="comment">//      {       </span></div>
<div class="line"><span class="comment">//              place_.div(     &quot;vert&quot;</span></div>
<div class="line"><span class="comment">//                              &quot;&lt;weight=34 margin=5          path       arrange=[variable,200] gap=5 &gt;&quot;</span></div>
<div class="line"><span class="comment">//                              &quot;&lt;weight=30 margin=[0,0,5,10] new_folder arrange=[100]                &gt;&quot;</span></div>
<div class="line"><span class="comment">//                              &quot;&lt;                            content    arrange=[180]          gap=[5]&gt;&quot;</span></div>
<div class="line"><span class="comment">//                &quot;&lt;weight=8&gt;&quot;</span></div>
<div class="line"><span class="comment">//                              &quot;&lt;weight=26 &lt;weight=100&gt; &quot;</span></div>
<div class="line"><span class="comment">//                &quot;           &lt;weight=60 vert   label      margin=[0,0,0,5]&gt;&quot;</span></div>
<div class="line"><span class="comment">//                              &quot;           &lt;                 file       margin=[0,18,0,5] arrange=[variable,variable,190] gap=[10]&gt;&gt;&quot;</span></div>
<div class="line"><span class="comment">//                              &quot;&lt;weight=48 margin=[8,0,14]&lt;&gt;&quot; );</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              place_.field( &quot;path&quot; )      &lt;&lt; path_     /*&lt;&lt;filter_*/;</span></div>
<div class="line"><span class="comment">//              place_.field( &quot;new_folder&quot; )&lt;&lt; btn_new_folder_ ;</span></div>
<div class="line"><span class="comment">//              place_.field( &quot;content&quot; )   &lt;&lt; tree_  &lt;&lt;  ls_file_;</span></div>
<div class="line"><span class="comment">//              place_.field( &quot;label&quot; )     &lt;&lt; lb_file_;</span></div>
<div class="line"><span class="comment">//              place_.field( &quot;file&quot; )      &lt;&lt; tb_file_ &lt;&lt; cb_types_;</span></div>
<div class="line"><span class="comment">//              place_.collocate();</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      void _m_init_tree()</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              using namespace nana::experimental::filesystem;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              //The path in linux start with the character &#39;/&#39;, the root key should be</span></div>
<div class="line"><span class="comment">//              //&quot;FS.HOME&quot;, &quot;FS.ROOT&quot;. Because a key of the tree widget should not be &#39;/&#39;</span></div>
<div class="line"><span class="comment">//              auto node_home = tree_.insert( (&quot;FS.HOME&quot;),  (&quot;Home&quot;));</span></div>
<div class="line"><span class="comment">//              node_home.value(kind::filesystem);</span></div>
<div class="line"><span class="comment">//              auto node_filesystem = tree_.insert( (&quot;FS.ROOT&quot;),  (&quot;Filesystem&quot;));</span></div>
<div class="line"><span class="comment">//              node_filesystem.value(kind::filesystem);</span></div>
<div class="line"><span class="comment">//              using SubDirectories =  directory_iterator;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              for (const auto&amp; dir : SubDirectories{ path_user() })</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      if ( !is_directory(dir) || (!dir.path().filename().empty() &amp;&amp; dir.path().filename().generic_u8string() [0] == &#39;.&#39;)) continue;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      item_proxy node = tree_.insert(node_home, dir.path().filename().generic_u8string(), dir.path().filename().generic_u8string());</span></div>
<div class="line"><span class="comment">//                      if( ! node.empty() )</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              node.value(dir); //node.value(kind::filesystem);</span></div>
<div class="line"><span class="comment">//                              break;</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              for (const auto&amp; dir : SubDirectories{  (&quot;/&quot;) })</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      if ( !is_directory(dir) || (!dir.path().filename().empty() &amp;&amp; dir.path().filename().generic_u8string()[0] == &#39;.&#39;)) continue;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      item_proxy node = tree_.insert(node_home, dir.path().filename().generic_u8string(), dir.path().filename().generic_u8string());</span></div>
<div class="line"><span class="comment">//                      if( ! node.empty() )</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              node.value(dir); //node.value(kind::filesystem);</span></div>
<div class="line"><span class="comment">//                              break;</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              tree_.events().expanded.connect_unignorable([this](const nana::arg_treebox&amp; arg)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      _m_tr_expand(arg.item, arg.operated);</span></div>
<div class="line"><span class="comment">//              });</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              tree_.events().selected.connect_unignorable([this](const nana::arg_treebox&amp; arg)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      if(arg.operated &amp;&amp;  ! arg.item.empty() )</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              auto path = tree_.make_key_path(arg.item,  (&quot;/&quot;)) +  (&quot;/&quot;);</span></div>
<div class="line"><span class="comment">//                              _m_resolute_path(path);</span></div>
<div class="line"><span class="comment">//                              _m_load_cat_path(path);</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//              });</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      std::string _m_resolute_path(std::string&amp; path)</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              auto pos = path.find( (&#39;/&#39;));</span></div>
<div class="line"><span class="comment">//              if(pos != path.npos)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      auto begstr = path.substr(0, pos);</span></div>
<div class="line"><span class="comment">//                      if(begstr ==  (&quot;FS.HOME&quot;))</span></div>
<div class="line"><span class="comment">//                              path.replace(0, 7, def_rootname);// nana::experimental::filesystem::path_user());</span></div>
<div class="line"><span class="comment">//                      else</span></div>
<div class="line"><span class="comment">//                              path.erase(0, pos);</span></div>
<div class="line"><span class="comment">//                      return begstr;</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//              return {};</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      void _m_load_path(const std::string&amp; path)</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              addr_.filesystem = path;</span></div>
<div class="line"><span class="comment">//              if(addr_.filesystem.size() &amp;&amp; addr_.filesystem[addr_.filesystem.size() - 1] !=  (&#39;/&#39;))</span></div>
<div class="line"><span class="comment">//                      addr_.filesystem +=  (&#39;/&#39;);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              file_container_.clear();</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              using namespace std::experimental::filesystem;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              file_status  fattr ; attribute ;</span></div>
<div class="line"><span class="comment">//              directory_iterator end;</span></div>
<div class="line"><span class="comment">//              for(directory_iterator i(path); i != end; ++i)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      if((!i-&gt;path().filename().empty() == 0) || (i-&gt;path().filename().generic_u8string()[0] ==  (&#39;.&#39;)))</span></div>
<div class="line"><span class="comment">//                              continue;</span></div>
<div class="line"><span class="comment">//                      item_fs m;</span></div>
<div class="line"><span class="comment">//                      m.name = i-&gt;path().filename();</span></div>
<div class="line"><span class="comment">//                      if(file_attrib(path + m.name, fattr))</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              m.bytes = fattr.size;</span></div>
<div class="line"><span class="comment">//                              m.directory = fattr.directory;</span></div>
<div class="line"><span class="comment">//                              m.modified_time = fattr.modified;</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//                      else</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              m.bytes = 0;</span></div>
<div class="line"><span class="comment">//                              m.directory = i-&gt;attr.directory;</span></div>
<div class="line"><span class="comment">//                              modified_file_time(path + i-&gt;path().filename().generic_u8string() , m.modified_time);</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      file_container_.push_back(m);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      if(m.directory)</span></div>
<div class="line"><span class="comment">//                              path_.childset(m.name, 0);</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//              std::sort(file_container_.begin(), file_container_.end(), pred_sort_fs());</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      void _m_load_cat_path(std::string path)</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              if((path.size() == 0) || (path[path.size() - 1] !=  (&#39;/&#39;)))</span></div>
<div class="line"><span class="comment">//                      path +=  (&#39;/&#39;);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              auto beg_node = tree_.selected();</span></div>
<div class="line"><span class="comment">//              while(!beg_node.empty() &amp;&amp; (beg_node != nodes_.home) &amp;&amp; (beg_node != nodes_.filesystem))</span></div>
<div class="line"><span class="comment">//                      beg_node = beg_node.owner();</span></div>
<div class="line"><span class="comment">//                      </span></div>
<div class="line"><span class="comment">//              auto head = filesystem::path_user();</span></div>
<div class="line"><span class="comment">//              if(path.size() &gt;= head.size() &amp;&amp; (path.substr(0, head.size()) == head))</span></div>
<div class="line"><span class="comment">//              {//This is HOME</span></div>
<div class="line"><span class="comment">//                      path_.caption( (&quot;HOME&quot;));</span></div>
<div class="line"><span class="comment">//                      if(beg_node != nodes_.home)</span></div>
<div class="line"><span class="comment">//                              nodes_.home-&gt;select(true);</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//              else</span></div>
<div class="line"><span class="comment">//              {       //Redirect to &#39;/&#39;</span></div>
<div class="line"><span class="comment">//                      path_.caption( (&quot;FILESYSTEM&quot;));</span></div>
<div class="line"><span class="comment">//                      if(beg_node != nodes_.filesystem)</span></div>
<div class="line"><span class="comment">//                              nodes_.filesystem-&gt;select(true);</span></div>
<div class="line"><span class="comment">//                      head.clear();</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              if(head.size() == 0 || head[head.size() - 1] !=  (&#39;/&#39;))</span></div>
<div class="line"><span class="comment">//                      head +=  (&#39;/&#39;);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              using namespace nana::experimental::filesystem;</span></div>
<div class="line"><span class="comment">//              directory_iterator end;</span></div>
<div class="line"><span class="comment">//              for(directory_iterator i(head); i != end; ++i)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      if(i-&gt;attr.directory)</span></div>
<div class="line"><span class="comment">//                              path_.childset(i-&gt;path().filename().generic_u8string(), 0);</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//              auto cat_path = path_.caption();</span></div>
<div class="line"><span class="comment">//              if(cat_path.size() &amp;&amp; cat_path[cat_path.size() - 1] !=  (&#39;/&#39;))</span></div>
<div class="line"><span class="comment">//                      cat_path +=  (&#39;/&#39;);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              auto beg = head.size();</span></div>
<div class="line"><span class="comment">//              while(true)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      auto pos = path.find( (&#39;/&#39;), beg);</span></div>
<div class="line"><span class="comment">//                      auto folder = path.substr(beg, pos != path.npos ? pos - beg: path.npos);</span></div>
<div class="line"><span class="comment">//                      if(folder.size() == 0)  ;</span></div>
<div class="line"><span class="comment">//                      (cat_path += folder) +=  (&#39;/&#39;);</span></div>
<div class="line"><span class="comment">//                      (head += folder) +=  (&#39;/&#39;);</span></div>
<div class="line"><span class="comment">//                      path_.caption(cat_path);</span></div>
<div class="line"><span class="comment">//                              </span></div>
<div class="line"><span class="comment">//                      for(nana::experimental::filesystem::directory_iterator i(head); i != end; ++i)</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              if (i-&gt;attr.directory)</span></div>
<div class="line"><span class="comment">//                                      path_.childset(i-&gt;path().filename().generic_u8string(), 0);</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      if(pos == path.npos)</span></div>
<div class="line"><span class="comment">//                              break;</span></div>
<div class="line"><span class="comment">//                      beg = pos + 1;</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//              _m_load_path(path);</span></div>
<div class="line"><span class="comment">//              _m_list_fs();</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      bool _m_filter_allowed(const std::string&amp; name, bool is_dir, const std::string&amp; filter, const std::vector&lt;std::string&gt;* extension) const</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              if(filter.size() &amp;&amp; (name.find(filter) == filter.npos))</span></div>
<div class="line"><span class="comment">//                      return false;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              if((is_dir || 0 == extension) || (0 == extension-&gt;size())) return true;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              for(auto &amp; extstr : *extension)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      auto pos = name.rfind(extstr);</span></div>
<div class="line"><span class="comment">//                      if((pos != name.npos) &amp;&amp; (name.size() == pos + extstr.size()))</span></div>
<div class="line"><span class="comment">//                              return true;</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//              return false;</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      void _m_list_fs()</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              std::string filter = filter_.caption();</span></div>
<div class="line"><span class="comment">//              ls_file_.auto_draw(false);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              ls_file_.clear();</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              std::vector&lt;std::string&gt;* ext_types = cb_types_.anyobj&lt;std::vector&lt;std::string&gt; &gt;(cb_types_.option());</span></div>
<div class="line"><span class="comment">//              auto cat = ls_file_.at(0);</span></div>
<div class="line"><span class="comment">//              for(auto &amp; fs: file_container_)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      if(_m_filter_allowed(fs.name, fs.directory, filter, ext_types))</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              cat.append(fs).value(fs);</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//              ls_file_.auto_draw(true);</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      void _m_finish(kind type, const std::string&amp; tar)</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              selection_.target = tar;</span></div>
<div class="line"><span class="comment">//              selection_.type = type;</span></div>
<div class="line"><span class="comment">//              close();</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      struct folder_creator</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              folder_creator(file_explorer&amp; fb, nana::form &amp; fm, nana::textbox&amp; tx)</span></div>
<div class="line"><span class="comment">//                      :       fb_(fb), fm_(fm), tx_path_(tx)</span></div>
<div class="line"><span class="comment">//              {}</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              void operator()()</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      auto path = tx_path_.caption();</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      nana::msgbox mb(fm_,  (&quot;Create Folder&quot;));</span></div>
<div class="line"><span class="comment">//                      mb.icon(nana::msgbox::icon_warning);</span></div>
<div class="line"><span class="comment">//                      if(0 == path.size() || path[0] ==  (&#39;.&#39;) || path[0] ==  (&#39;/&#39;))</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              mb&lt;&lt; (&quot;Please input a valid name for the new folder.&quot;);</span></div>
<div class="line"><span class="comment">//                              mb();</span></div>
<div class="line"><span class="comment">//                              return;</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//                              </span></div>
<div class="line"><span class="comment">//                      bool if_exist;</span></div>
<div class="line"><span class="comment">//                      if(false == filesystem::mkdir(fb_.addr_.filesystem + path, if_exist))</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              if(if_exist)</span></div>
<div class="line"><span class="comment">//                                      mb&lt;&lt; (&quot;The folder is existing, please rename it.&quot;);</span></div>
<div class="line"><span class="comment">//                              else</span></div>
<div class="line"><span class="comment">//                                      mb&lt;&lt; (&quot;Failed to create the folder, please rename it.&quot;);</span></div>
<div class="line"><span class="comment">//                              mb();</span></div>
<div class="line"><span class="comment">//                              return;</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//                      fb_._m_load_cat_path(fb_.addr_.filesystem);</span></div>
<div class="line"><span class="comment">//                      fm_.close();</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              file_explorer&amp; fb_;</span></div>
<div class="line"><span class="comment">//              nana::form&amp; fm_;</span></div>
<div class="line"><span class="comment">//              nana::textbox &amp; tx_path_;</span></div>
<div class="line"><span class="comment">//      };</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      bool _m_append_def_extension(std::string&amp; tar) const</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              auto dotpos = tar.find_last_of( (&#39;.&#39;));</span></div>
<div class="line"><span class="comment">//              if(dotpos != tar.npos)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      auto pos = tar.find_last_of( (&quot;/\\&quot;));</span></div>
<div class="line"><span class="comment">//                      if(pos == tar.npos || pos &lt; dotpos)</span></div>
<div class="line"><span class="comment">//                              return false;</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              std::vector&lt;nana::string&gt; * exts = cb_types_.anyobj&lt;std::vector&lt;std::string&gt; &gt;(cb_types_.option());</span></div>
<div class="line"><span class="comment">//              if(0 == exts || exts-&gt;size() == 0)      return false;</span></div>
<div class="line"><span class="comment">//                      </span></div>
<div class="line"><span class="comment">//              auto &amp; ext = exts-&gt;at(0);</span></div>
<div class="line"><span class="comment">//              tar += ext;</span></div>
<div class="line"><span class="comment">//              return true;</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//private:</span></div>
<div class="line"><span class="comment">//      void _m_sel_file(const nana::arg_mouse&amp; arg)</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              auto sel = ls_file_.selected();</span></div>
<div class="line"><span class="comment">//              if(sel.empty())</span></div>
<div class="line"><span class="comment">//                      return;</span></div>
<div class="line"><span class="comment">//                      </span></div>
<div class="line"><span class="comment">//              auto index = sel[0];</span></div>
<div class="line"><span class="comment">//              item_fs m;</span></div>
<div class="line"><span class="comment">//              ls_file_.at(index).resolve_to(m);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              if(nana::event_code::dbl_click == arg.evt_code)</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      if(m.directory)</span></div>
<div class="line"><span class="comment">//                              _m_load_cat_path(addr_.filesystem + m.name +  (&quot;/&quot;));</span></div>
<div class="line"><span class="comment">//                      else</span></div>
<div class="line"><span class="comment">//                              _m_finish(kind::filesystem, addr_.filesystem + m.name);</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//              else</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      if(false == m.directory)</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              selection_.target = addr_.filesystem + m.name;</span></div>
<div class="line"><span class="comment">//                              tb_file_.caption(m.name);</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      void _m_ok()</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              if(0 == selection_.target.size())</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      auto file = tb_file_.caption();</span></div>
<div class="line"><span class="comment">//                      if(file.size())</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              if(file[0] ==  (&#39;.&#39;))</span></div>
<div class="line"><span class="comment">//                              {</span></div>
<div class="line"><span class="comment">//                                      nana::msgbox mb(*this, caption());</span></div>
<div class="line"><span class="comment">//                                      mb.icon(nana::msgbox::icon_warning);</span></div>
<div class="line"><span class="comment">//                                      mb&lt;&lt;file&lt;&lt;std::endl&lt;&lt; (&quot;The filename is invalid.&quot;);</span></div>
<div class="line"><span class="comment">//                                      mb();</span></div>
<div class="line"><span class="comment">//                                      return;</span></div>
<div class="line"><span class="comment">//                              }</span></div>
<div class="line"><span class="comment">//                              std::string tar;</span></div>
<div class="line"><span class="comment">//                              if(file[0] ==  (&#39;/&#39;))</span></div>
<div class="line"><span class="comment">//                                      tar = file;</span></div>
<div class="line"><span class="comment">//                              else</span></div>
<div class="line"><span class="comment">//                                      tar = addr_.filesystem + file;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                              bool good = true;</span></div>
<div class="line"><span class="comment">//                              filesystem::attribute attr;</span></div>
<div class="line"><span class="comment">//                              if(filesystem::file_attrib(tar, attr) == false)</span></div>
<div class="line"><span class="comment">//                              {</span></div>
<div class="line"><span class="comment">//                                      if(_m_append_def_extension(tar))</span></div>
<div class="line"><span class="comment">//                                              good = filesystem::file_attrib(tar, attr);</span></div>
<div class="line"><span class="comment">//                                      else</span></div>
<div class="line"><span class="comment">//                                              good = false;</span></div>
<div class="line"><span class="comment">//                              }</span></div>
<div class="line"><span class="comment">//                                      </span></div>
<div class="line"><span class="comment">//                              if(good &amp;&amp; attr.is_directory)</span></div>
<div class="line"><span class="comment">//                              {</span></div>
<div class="line"><span class="comment">//                                      _m_load_cat_path(tar);</span></div>
<div class="line"><span class="comment">//                                      tb_file_.caption( (&quot;&quot;));</span></div>
<div class="line"><span class="comment">//                                      return;</span></div>
<div class="line"><span class="comment">//                              }</span></div>
<div class="line"><span class="comment">//                                      </span></div>
<div class="line"><span class="comment">//                              {</span></div>
<div class="line"><span class="comment">//                                      if(good)</span></div>
<div class="line"><span class="comment">//                                      {</span></div>
<div class="line"><span class="comment">//                                              nana::msgbox mb(*this, caption(), nana::msgbox::yes_no);</span></div>
<div class="line"><span class="comment">//                                              mb.icon(nana::msgbox::icon_question);</span></div>
<div class="line"><span class="comment">//                                              mb&lt;&lt; (&quot;The input file is existing, do you want to overwrite it?&quot;);</span></div>
<div class="line"><span class="comment">//                                              if(nana::msgbox::pick_no == mb())</span></div>
<div class="line"><span class="comment">//                                                      return;</span></div>
<div class="line"><span class="comment">//                                      }</span></div>
<div class="line"><span class="comment">//                                      _m_finish(kind::filesystem, tar);</span></div>
<div class="line"><span class="comment">//                              }</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//              else</span></div>
<div class="line"><span class="comment">//                      _m_finish(kind::filesystem, selection_.target);</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      void _m_tr_expand(item_proxy node, bool exp)</span></div>
<div class="line"><span class="comment">//      {</span></div>
<div class="line"><span class="comment">//              if(false == exp) return;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              if( ! node.empty())</span></div>
<div class="line"><span class="comment">//              {</span></div>
<div class="line"><span class="comment">//                      std::string path = tree_.make_key_path(node,  (&quot;/&quot;)) +  (&quot;/&quot;);</span></div>
<div class="line"><span class="comment">//                      _m_resolute_path(path);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                      using namespace nana::experimental::filesystem;</span></div>
<div class="line"><span class="comment">//                      directory_iterator end;</span></div>
<div class="line"><span class="comment">//                      for(directory_iterator i(path); i != end; ++i)</span></div>
<div class="line"><span class="comment">//                      {</span></div>
<div class="line"><span class="comment">//                              if((false == i-&gt;attr.directory) || (i-&gt;path().filename().size() &amp;&amp; i-&gt;path().filename().generic_u8string()[0] == &#39;.&#39;)) continue;</span></div>
<div class="line"><span class="comment">//                              auto child = node.append(i-&gt;path().filename().generic_u8string(), i-&gt;path().filename().generic_u8string(), *i);</span></div>
<div class="line"><span class="comment">//                              if(!child.empty())</span></div>
<div class="line"><span class="comment">//                              {</span></div>
<div class="line"><span class="comment">//                                      for(directory_iterator u(path + i-&gt;path().filename().generic_u8string()); u != end; ++u)</span></div>
<div class="line"><span class="comment">//                                      {</span></div>
<div class="line"><span class="comment">//                                              if(! u-&gt;attr.directory || (!u-&gt;path().filename().empty() &amp;&amp; u-&gt;path().filename().generic_u8string()[0] == &#39;.&#39;)) continue;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//                                              child.append(u-&gt;path().filename().generic_u8string(), u-&gt;path().filename().generic_u8string(), *i);</span></div>
<div class="line"><span class="comment">//                                              break;</span></div>
<div class="line"><span class="comment">//                                      }</span></div>
<div class="line"><span class="comment">//                              }</span></div>
<div class="line"><span class="comment">//                      }</span></div>
<div class="line"><span class="comment">//              }</span></div>
<div class="line"><span class="comment">//      }</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//};//end class filebox_implement</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//std::string file_explorer::saved_init_path;</span></div>
<div class="line"><span class="comment">//std::string file_explorer::saved_selected_path;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// using namespace nana;</span></div>
<div class="line">        <span class="comment">// d_node d{ def_rootstr };</span></div>
<div class="line">        explorer fb( f_name, </div>
<div class="line">                         children, </div>
<div class="line">                         l_items,</div>
<div class="line">                                 { { (<span class="stringliteral">&quot;Name&quot;</span>), 190 }, { (<span class="stringliteral">&quot;Modified&quot;</span>), 145 }, { (<span class="stringliteral">&quot;Type&quot;</span>), 80 }, { (<span class="stringliteral">&quot;Size&quot;</span>), 70 }  });</div>
<div class="line"></div>
<div class="line">        fb.add_root(fs_ext::def_root, fs_ext::def_rootname, d_node{ fs_ext::def_rootstr }).<a class="code" href="../../dc/d5e/namespacenana_1_1widgets_1_1skeletons.html#a0fd7869430e15570cd19e2a4bdd28647a99938282f04071859941e18f16efcf42">select</a>(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">    fb.show();</div>
<div class="line">    <a name="a24"></a><a class="code" href="../../d2/d76/namespacenana.html#adfeaf4a48fd8f02161268cde0ae797d9">nana::exec</a>();</div>
<div class="line">    <span class="comment">//char a;</span></div>
<div class="line">    <span class="comment">//std::cin &gt;&gt; a;</span></div>
<div class="line">}</div>
<div class="line"></div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
